-- This is to preserve old code (for convenience instead of searching github)

-- def hypsubspace_two {β:BilinForm k V} {e f : V} (_:hyp_pair β e f) : Submodule k V :=
--   Submodule.span k {e,f}

-- theorem hyp2_nondeg_refl (β:BilinForm k V)
--   (brefl : IsRefl β) {e f : V} (h2: hyp_pair β e f) :
--   NondegenerateOn β (hypsubspace_two h2).toSubmodule := by
--     rintro ⟨v, hv⟩  h
--     -- simp at hv
--     have: ∃(a b: k), v = a • e + b • f := by
--       unfold hypsubspace_two at hv
--       -- exact exists_two_coefficients_of_in_span_pair e f v hv
--       sorry
--     have ⟨a,b,hab⟩ := this
--     have hve: β v e = 0 := by
--       have he: e ∈ (hypsubspace_two h2).toSubmodule := by
--         simp[hypsubspace_two]
--         suffices e ∈ ({e,f} : Set V)from ?_
--         . -- exact Submodule.mem_span_of_mem this
--           sorry
--         exact Set.mem_insert e {f}
--       apply h ⟨e, he⟩

--     have hvf: β v f = 0 := by
--       have hf: f ∈ (hypsubspace_two h2).toSubmodule := by
--         simp[hypsubspace_two]
--         suffices f ∈ ({e,f} : Set V)from ?_
--         . -- exact Submodule.mem_span_of_mem this
--           sorry
--         exact Set.mem_insert_of_mem e rfl
--       apply h ⟨f, hf⟩

--     have hveb: β e v = b := by
--       calc
--         β e v = β e (a• e + b • f) := by rw[hab]
--         _ = a * β e e + b * β e f := by simp
--         _ = a * 0 + b * 1 := by
--           unfold hyp_pair at h2
--           have: β e e = 0 := by
--             exact h2.left
--           have: β e f= 1 := by
--             exact h2.right.right
--           simp[*]
--         _ =  b := by simp
--     have hvfa: β v f = a:= by
--         calc
--         β v f = β (a• e + b • f) f := by rw[hab]
--         _ = a * β e f + b * β f f := by simp
--         _ = a * 1 + b * 0 := by
--           unfold hyp_pair at h2
--           have: β e f = 1 := by
--             exact h2.right.right
--           have: β f f = 0 := by
--             exact h2.right.left
--           simp[*]
--         _ = a := by simp
--     have hva: a=0 :=
--       calc
--         a= β v f := hvfa.symm
--         _ = 0 := hvf
--     have hvb: b=0 := by
--       have hve': β e v = 0 := brefl v e hve
--       calc
--         b = β e v:= hveb.symm
--         _ = 0 := hve'

--     simp[hab,hva,hvb]


-- lemma in_span_fin_iff_linear_combination (n: ℕ) (v: V) (vect: Fin n → V) (hv : v ∈ Submodule.span k (Set.range vect)) :
--   ∃(f: Fin n → k), v = ∑ i, f i • (vect i) := by
--     rw[Submodule.mem_span_range_iff_exists_fun] at hv
--     have ⟨c, hc⟩ := hv
--     use c
--     symm
--     exact hc

-- lemma in_span_fin_two_iff_linear_combination (v: V) (vect: Fin 2 → V) (hv : v ∈ Submodule.span k (Set.range vect)) :
--   ∃(f: Fin 2 → k), v = ∑ i, f i • (vect i) := by
--     exact in_span_fin_iff_linear_combination (2: ℕ) (v: V) (vect: Fin 2 → V) hv

-- def fun_fin_two_to_pair (e f : V) : Fin 2 → V
-- | ⟨0, _⟩ => e
-- | ⟨1, _⟩ => f

-- lemma exists_two_coefficients_of_in_span_pair (v1 v2 v : V)(hv : v ∈ Submodule.span k {v1, v2}) :
--   ∃(a b: k), v = a • v1 + b • v2 := by
--     have: {v1, v2} = Set.range (fun_fin_two_to_pair v1 v2):= by
--       ext x
--       constructor
--       . rintro (h | h)
--         . use 0; simp only [fun_fin_two_to_pair]; tauto
--         . use 1; simp only [fun_fin_two_to_pair]; symm; exact h
--       . rintro ⟨y, rfl⟩
--         match y with
--         | ⟨0, _⟩ => simp[fun_fin_two_to_pair]
--         | ⟨1, _⟩ => simp[fun_fin_two_to_pair]
--     rw[this] at hv
--     have ⟨f, hv⟩ := in_span_fin_two_iff_linear_combination v (fun_fin_two_to_pair v1 v2) hv
--     use f 0, f 1
--     rw[hv]
--     exact Fin.sum_univ_two fun i ↦ f i • fun_fin_two_to_pair v1 v2 i
